# OpenArm

[OpenArm](https://openarm.dev) is an open-source 7DOF humanoid arm designed for physical AI research and deployment.

To get your OpenArm, assembled or DIY, and join the global community, browse verified and certified manufacturers worldwide at [openarm.dev](https://openarm.dev).

## What's Unique?

- **Human-Scale Design**: OpenArm is designed with human-like proportions, scaled for a person around 160-165cm tall. This provides an optimal balance between practical reach and manageable inertia for safe, responsive operation.

- **Safety-First Architecture**: Built with QDD backdrivable motors and high compliance, OpenArm prioritizes safe human-robot interaction while maintaining practical payload capabilities (6.0kg peak / 4.1kg nominal) for real-world tasks.

- **Built for Durability**: Critical structural components use aluminum and stainless steel construction, ensuring robust performance for repetitive data collection and continuous research use.

- **Fully Accessible & Buildable**: Every component, from CNC parts and 3D-printed casings to electrical wiring is designed to be purchasable and buildable by individual researchers and labs, with complete fabrication data provided.

- **Practical & Affordable**: At $6,500 USD for a complete bimanual system, OpenArm delivers research-grade capabilities at a fraction of traditional humanoid robot costs.

## Platform Requirements

<Tip warning={true}>
  **Linux Only**: OpenArm currently only works on Linux. The CAN bus USB adapter
  does not have macOS drivers and has not been tested on Windows.
</Tip>

## Safety Guide

Before operating OpenArm, please read the [official safety guide](https://docs.openarm.dev/getting-started/safety-guide). Key points:

- **Secure installation**: Fasten the arm to a flat, stable surface with screws or clamps
- **Safe distance**: Keep body parts and objects outside the range of motion during operation
- **Protective equipment**: Always wear safety goggles; use additional PPE as needed
- **Payload limits**: Do not exceed specified payload limits (6.0kg peak / 4.1kg nominal per arm)
- **Emergency stop**: Know the location and operation of the emergency stop device
- **Regular inspection**: Check for loose screws, damaged mechanical limits, unusual noises, and wiring damage

## Hardware Setup

Follow the official [OpenArm hardware documentation](https://docs.openarm.dev) for:

- Bill of materials and sourcing
- 3D printing instructions
- Mechanical assembly
- Electrical wiring

The hardware repositories are available at [github.com/enactic/openarm](https://github.com/enactic/openarm).

## CAN Bus Setup

OpenArm uses CAN bus communication with Damiao motors. Once you have the CAN bus USB adapter plugged into your Linux PC, follow the [Damiao Motors and CAN Bus guide](./damiao) to configure the interface.

Quick setup:

```bash
# Setup CAN interfaces
lerobot-setup-can --mode=setup --interfaces=can0,can1

# Test motor communication
lerobot-setup-can --mode=test --interfaces=can0,can1
```

## Install LeRobot ü§ó

Follow our [Installation Guide](./installation), then install the Damiao motor support:

```bash
pip install -e ".[damiao]"
```

## Usage

### Follower Arm (Robot)

<hfoptions id="follower">
<hfoption id="Command">

```bash
lerobot-calibrate \
    --robot.type=openarm_follower \
    --robot.port=can0 \
    --robot.side=right \
    --robot.id=my_openarm_follower
```

</hfoption>
<hfoption id="API example">

```python
from lerobot.robots.openarm_follower import OpenArmFollower, OpenArmFollowerConfig

config = OpenArmFollowerConfig(
    port="can0",
    side="right",  # or "left" for left arm
    id="my_openarm_follower",
)

follower = OpenArmFollower(config)
follower.connect()

# Read current state
obs = follower.get_observation()
print(obs)

# Send action (position in degrees)
action = {
    "joint_1.pos": 0.0,
    "joint_2.pos": 0.0,
    "joint_3.pos": 0.0,
    "joint_4.pos": 45.0,
    "joint_5.pos": 0.0,
    "joint_6.pos": 0.0,
    "joint_7.pos": 0.0,
    "gripper.pos": 0.0,
}
follower.send_action(action)

follower.disconnect()
```

</hfoption>
</hfoptions>

### Leader Arm (Teleoperator)

The leader arm is used for teleoperation - manually moving it to control the follower arm.

<hfoptions id="leader">
<hfoption id="Command">

```bash
lerobot-calibrate \
    --teleop.type=openarm_leader \
    --teleop.port=can1 \
    --teleop.id=my_openarm_leader
```

</hfoption>
<hfoption id="API example">

```python
from lerobot.teleoperators.openarm_leader import OpenArmLeader, OpenArmLeaderConfig

config = OpenArmLeaderConfig(
    port="can1",
    id="my_openarm_leader",
    manual_control=True,  # Disable torque for manual movement
)

leader = OpenArmLeader(config)
leader.connect()

# Read current position (as action to send to follower)
action = leader.get_action()
print(action)

leader.disconnect()
```

</hfoption>
</hfoptions>

### Teleoperation

To teleoperate OpenArm with leader-follower control:

```bash
lerobot-teleoperate \
    --robot.type=openarm_follower \
    --robot.port=can0 \
    --robot.side=right \
    --robot.id=my_follower \
    --teleop.type=openarm_leader \
    --teleop.port=can1 \
    --teleop.id=my_leader
```

### Bimanual Teleoperation

To teleoperate a bimanual OpenArm setup with two leader and two follower arms:

```bash
lerobot-teleoperate \
    --robot.type=bi_openarm_follower \
    --robot.left_arm_config.port=can0 \
    --robot.left_arm_config.side=left \
    --robot.right_arm_config.port=can1 \
    --robot.right_arm_config.side=right \
    --robot.id=my_bimanual_follower \
    --teleop.type=bi_openarm_leader \
    --teleop.left_arm_config.port=can2 \
    --teleop.right_arm_config.port=can3 \
    --teleop.id=my_bimanual_leader
```

### Recording Data

To record a dataset during teleoperation:

```bash
lerobot-record \
    --robot.type=openarm_follower \
    --robot.port=can0 \
    --robot.side=right \
    --robot.id=my_follower \
    --teleop.type=openarm_leader \
    --teleop.port=can1 \
    --teleop.id=my_leader \
    --repo-id=my_hf_username/my_openarm_dataset \
    --fps=30 \
    --num-episodes=10
```

## Configuration Options

### Follower Configuration

| Parameter             | Default   | Description                                                |
| --------------------- | --------- | ---------------------------------------------------------- |
| `port`                | -         | CAN interface (e.g., `can0`)                               |
| `side`                | `None`    | Arm side: `"left"`, `"right"`, or `None` for custom limits |
| `use_can_fd`          | `True`    | Enable CAN FD for higher data rates                        |
| `can_bitrate`         | `1000000` | Nominal bitrate (1 Mbps)                                   |
| `can_data_bitrate`    | `5000000` | CAN FD data bitrate (5 Mbps)                               |
| `max_relative_target` | `None`    | Safety limit for relative target positions                 |
| `position_kp`         | Per-joint | Position control proportional gains                        |
| `position_kd`         | Per-joint | Position control derivative gains                          |

### Leader Configuration

| Parameter          | Default   | Description                         |
| ------------------ | --------- | ----------------------------------- |
| `port`             | -         | CAN interface (e.g., `can1`)        |
| `manual_control`   | `True`    | Disable torque for manual movement  |
| `use_can_fd`       | `True`    | Enable CAN FD for higher data rates |
| `can_bitrate`      | `1000000` | Nominal bitrate (1 Mbps)            |
| `can_data_bitrate` | `5000000` | CAN FD data bitrate (5 Mbps)        |

## Gravity Compensation

OpenArm Leader supports gravity compensation to reduce the perceived weight of the arm during teleoperation. This feature uses inverse dynamics (RNEA) to compute and apply torques that counteract gravity, making the arm feel significantly lighter and easier to manipulate.

### Requirements

- **URDF Model**: A robot description file containing mass and inertia properties
- **Pinocchio**: Robotics library for dynamics computation (`pip install pin`)
- **Linux**: Required for CAN bus support

### Setup

1. **Obtain the URDF model** from the [official OpenArm repository](https://github.com/enactic/openarm):
   ```bash
   # Download and place in the appropriate directory
   # See src/lerobot/teleoperators/openarm_leader/URDF_README.md for details
   ```

2. **Enable gravity compensation** in your configuration:
   ```yaml
   teleoperator:
     type: openarm_leader
     port: can1
     manual_control: false  # Must be false for gravity compensation
     gravity_compensation: true
     gravity_compensation_gain: 1.0  # Start with 1.0, adjust during calibration
     urdf_path: "${LEROBOT_ROOT}/src/lerobot/teleoperators/openarm_leader/openarm.urdf"
   ```

3. **Calibrate the gain** to match your specific robot:
   - See the [Gravity Compensation Calibration Guide](./openarm_gravity_calibration) for detailed instructions

### Usage Example

<hfoptions id="gravity-comp">
<hfoption id="Command">

```bash
lerobot-teleoperate \
    --robot.type=openarm_follower \
    --robot.port=can0 \
    --teleop.type=openarm_leader \
    --teleop.port=can1 \
    --teleop.manual_control=false \
    --teleop.gravity_compensation=true \
    --teleop.gravity_compensation_gain=1.0
```

</hfoption>
<hfoption id="API example">

```python
from lerobot.teleoperators.openarm_leader import OpenArmLeader, OpenArmLeaderConfig

config = OpenArmLeaderConfig(
    port="can1",
    id="my_openarm_leader",
    manual_control=False,  # Required for gravity compensation
    gravity_compensation=True,
    gravity_compensation_gain=1.0,  # Adjust based on calibration
    urdf_path="${LEROBOT_ROOT}/src/lerobot/teleoperators/openarm_leader/openarm.urdf",
)

leader = OpenArmLeader(config)
leader.connect()

# The arm now applies gravity compensation torques automatically
# during get_action() calls, making it feel lighter
action = leader.get_action()

leader.disconnect()
```

</hfoption>
</hfoptions>

### Bimanual Gravity Compensation

For bimanual setups, enable gravity compensation for both arms:

```bash
lerobot-teleoperate \
    --robot.type=bi_openarm_follower \
    --robot.left_arm_config.port=can0 \
    --robot.right_arm_config.port=can1 \
    --teleop.type=bi_openarm_leader \
    --teleop.left_arm_config.port=can2 \
    --teleop.left_arm_config.manual_control=false \
    --teleop.right_arm_config.port=can3 \
    --teleop.right_arm_config.manual_control=false \
    --teleop.gravity_compensation=true \
    --teleop.gravity_compensation_gain=1.0
```

### Configuration Parameters

| Parameter                       | Default                                     | Description                                                                 |
| ------------------------------- | ------------------------------------------- | --------------------------------------------------------------------------- |
| `gravity_compensation`          | `False`                                     | Enable gravity compensation                                                 |
| `gravity_compensation_gain`     | `1.0`                                       | Scaling factor for torques (0.7-1.3 typical range)                         |
| `urdf_path`                     | `${LEROBOT_ROOT}/.../openarm.urdf`          | Path to URDF model file                                                     |
| `gravity_vector`                | `[0.0, 0.0, -9.81]`                         | Gravity vector in base frame (m/s¬≤)                                         |
| `software_torque_limits`        | `[8.0, 8.0, 5.0, 5.0, 2.0, 2.0, 2.0]`       | Per-joint torque limits (Nm) for safety                                     |
| `gravity_comp_position_kp`      | `[50.0, 50.0, 50.0, 50.0, 10.0, ...]`       | Soft MIT control gains for gravity compensation mode                        |
| `gravity_comp_position_kd`      | `[2.0, 2.0, 2.0, 2.0, 0.2, ...]`            | Soft MIT control damping for gravity compensation mode                      |

### Important Notes

‚ö†Ô∏è **URDF Accuracy**: The URDF model contains idealized physical parameters that may not match your robot due to:
   - 3D printing variations (infill, material density)
   - Cable routing and wiring weight
   - Mounted sensors or cameras
   - Manufacturing tolerances

Use `gravity_compensation_gain` to compensate for these differences. See the [calibration guide](./openarm_gravity_calibration) for step-by-step instructions.

‚ö†Ô∏è **Performance**: Gravity compensation adds 1-3ms of computation per control cycle. This is acceptable for typical 200-500 Hz control rates.

‚ö†Ô∏è **Safety**: Software torque limits prevent excessive torques from URDF errors or sensor noise. Do not disable these limits.

### Expected Results

After proper calibration:
- **Reduced perceived weight**: Arm feels 70-90% lighter
- **Stable holding**: < 5cm drift over 30 seconds in horizontal pose  
- **No oscillations**: Smooth, stable control at all joints
- **Responsive**: Natural teleoperation feel without lag

### Troubleshooting

**Arm drifts downward:**
- Increase `gravity_compensation_gain` in 0.05 increments (e.g., 1.0 ‚Üí 1.05 ‚Üí 1.10)

**Arm floats upward:**
- Decrease `gravity_compensation_gain` in 0.05 increments (e.g., 1.0 ‚Üí 0.95 ‚Üí 0.90)

**Arm oscillates/vibrates:**
- Reduce `gravity_comp_position_kp` and `gravity_comp_position_kd` by 20-30%

**Gravity compensation not working:**
- Verify URDF exists: `ls -l $LEROBOT_ROOT/src/lerobot/teleoperators/openarm_leader/openarm.urdf`
- Check Pinocchio installation: `python -c "import pinocchio; print(pinocchio.__version__)"`
- Ensure `manual_control=false` in configuration
- Check logs for errors: Look for "Gravity compensation error" messages

For detailed troubleshooting, see the [calibration guide](./openarm_gravity_calibration).

## Motor Configuration

OpenArm uses Damiao motors with the following default configuration:

| Joint                       | Motor Type | Send ID | Recv ID |
| --------------------------- | ---------- | ------- | ------- |
| joint_1 (Shoulder pan)      | DM8009     | 0x01    | 0x11    |
| joint_2 (Shoulder lift)     | DM8009     | 0x02    | 0x12    |
| joint_3 (Shoulder rotation) | DM4340     | 0x03    | 0x13    |
| joint_4 (Elbow flex)        | DM4340     | 0x04    | 0x14    |
| joint_5 (Wrist roll)        | DM4310     | 0x05    | 0x15    |
| joint_6 (Wrist pitch)       | DM4310     | 0x06    | 0x16    |
| joint_7 (Wrist rotation)    | DM4310     | 0x07    | 0x17    |
| gripper                     | DM4310     | 0x08    | 0x18    |

## Troubleshooting

### No Response from Motors

1. Check power supply connections
2. Verify CAN wiring (CAN-H, CAN-L, GND)
3. Run diagnostics: `lerobot-setup-can --mode=test --interfaces=can0`
4. See the [Damiao troubleshooting guide](./damiao#troubleshooting) for more details

### CAN Interface Not Found

Ensure the CAN interface is configured:

```bash
ip link show can0
```

## Resources

- [OpenArm Website](https://openarm.dev)
- [OpenArm Documentation](https://docs.openarm.dev)
- [OpenArm GitHub](https://github.com/enactic/openarm)
- [Safety Guide](https://docs.openarm.dev/getting-started/safety-guide)
- [Damiao Motors and CAN Bus](./damiao)
